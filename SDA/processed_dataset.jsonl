{"prompt": "### Repository:\n                pallets/flask\n\n                ### Issue:\n                pass sys.argv to flask cli\n\n                ### Buggy Code Patch:\n                @@ -57,4 +57,4 @@\n from .templating import render_template\n from .templating import render_template_string\n \n-__version__ = \"1.1.1\"\n+__version__ = \"1.1.2.dev\"\n\n                ### Fix the Code:", "completion": "__version__ = \"1.1.2.dev\""}
{"prompt": "### Repository:\n                pallets/flask\n\n                ### Issue:\n                pass sys.argv to flask cli\n\n                ### Buggy Code Patch:\n                @@ -963,7 +963,8 @@ def routes_command(sort, all_methods):\n \n \n def main(as_module=False):\n-    cli.main(prog_name=\"python -m flask\" if as_module else None)\n+    # TODO omit sys.argv once https://github.com/pallets/click/issues/536 is fixed\n+    cli.main(args=sys.argv[1:], prog_name=\"python -m flask\" if as_module else None)\n \n \n if __name__ == \"__main__\":\n\n                ### Fix the Code:", "completion": "# TODO omit sys.argv once https://github.com/pallets/click/issues/536 is fixed\n    cli.main(args=sys.argv[1:], prog_name=\"python -m flask\" if as_module else None)"}
{"prompt": "### Repository:\n                pallets/flask\n\n                ### Issue:\n                Only trap key errors by default in debug, not all BadRequest errors\n\n                ### Buggy Code Patch:\n                @@ -1663,8 +1663,14 @@ def trap_http_exception(self, e):\n \n         trap_bad_request = self.config['TRAP_BAD_REQUEST_ERRORS']\n \n-        # if unset, trap based on debug mode\n-        if (trap_bad_request is None and self.debug) or trap_bad_request:\n+        # if unset, trap key errors in debug mode\n+        if (\n+            trap_bad_request is None and self.debug\n+            and isinstance(e, BadRequestKeyError)\n+        ):\n+            return True\n+\n+        if trap_bad_request:\n             return isinstance(e, BadRequest)\n \n         return False\n\n                ### Fix the Code:", "completion": "# if unset, trap key errors in debug mode\n        if (\n            trap_bad_request is None and self.debug\n            and isinstance(e, BadRequestKeyError)\n        ):\n            return True\n\n        if trap_bad_request:"}
{"prompt": "### Repository:\n                pallets/flask\n\n                ### Issue:\n                Only trap key errors by default in debug, not all BadRequest errors\n\n                ### Buggy Code Patch:\n                @@ -1027,21 +1027,34 @@ def raise_e3():\n \n \n def test_trapping_of_bad_request_key_errors(app, client):\n-    @app.route('/fail')\n+    @app.route('/key')\n     def fail():\n         flask.request.form['missing_key']\n \n-    rv = client.get('/fail')\n+    @app.route('/abort')\n+    def allow_abort():\n+        flask.abort(400)\n+\n+    rv = client.get('/key')\n     assert rv.status_code == 400\n     assert b'missing_key' not in rv.data\n+    rv = client.get('/abort')\n+    assert rv.status_code == 400\n \n-    app.config['TRAP_BAD_REQUEST_ERRORS'] = True\n-\n+    app.debug = True\n     with pytest.raises(KeyError) as e:\n-        client.get(\"/fail\")\n-\n+        client.get(\"/key\")\n     assert e.errisinstance(BadRequest)\n     assert 'missing_key' in e.value.description\n+    rv = client.get('/abort')\n+    assert rv.status_code == 400\n+\n+    app.debug = False\n+    app.config['TRAP_BAD_REQUEST_ERRORS'] = True\n+    with pytest.raises(KeyError):\n+        client.get('/key')\n+    with pytest.raises(BadRequest):\n+        client.get('/abort')\n \n \n def test_trapping_of_all_http_exceptions(app, client):\n\n                ### Fix the Code:", "completion": "@app.route('/key')\n    @app.route('/abort')\n    def allow_abort():\n        flask.abort(400)\n\n    rv = client.get('/key')\n    rv = client.get('/abort')\n    assert rv.status_code == 400\n    app.debug = True\n        client.get(\"/key\")\n    rv = client.get('/abort')\n    assert rv.status_code == 400\n\n    app.debug = False\n    app.config['TRAP_BAD_REQUEST_ERRORS'] = True\n    with pytest.raises(KeyError):\n        client.get('/key')\n    with pytest.raises(BadRequest):\n        client.get('/abort')"}
{"prompt": "### Repository:\n                pallets/flask\n\n                ### Issue:\n                merge slashes between blueprint prefix and rule\n\n                ### Buggy Code Patch:\n                @@ -49,12 +49,10 @@ def __init__(self, blueprint, app, options, first_registration):\n         url_prefix = self.options.get('url_prefix')\n         if url_prefix is None:\n             url_prefix = self.blueprint.url_prefix\n-\n+        if url_prefix:\n+            url_prefix = url_prefix.rstrip('/')\n         #: The prefix that should be used for all URLs defined on the\n         #: blueprint.\n-        if url_prefix and url_prefix[-1] == '/':\n-            url_prefix = url_prefix[:-1]\n-\n         self.url_prefix = url_prefix\n \n         #: A dictionary with URL defaults that is added to each and every\n@@ -68,7 +66,7 @@ def add_url_rule(self, rule, endpoint=None, view_func=None, **options):\n         blueprint's name.\n         \"\"\"\n         if self.url_prefix:\n-            rule = self.url_prefix + rule\n+            rule = '/'.join((self.url_prefix, rule.lstrip('/')))\n         options.setdefault('subdomain', self.subdomain)\n         if endpoint is None:\n             endpoint = _endpoint_from_view_func(view_func)\n\n                ### Fix the Code:", "completion": "if url_prefix:\n            url_prefix = url_prefix.rstrip('/')\n            rule = '/'.join((self.url_prefix, rule.lstrip('/')))"}
{"prompt": "### Repository:\n                pallets/flask\n\n                ### Issue:\n                merge slashes between blueprint prefix and rule\n\n                ### Buggy Code Patch:\n                @@ -115,17 +115,22 @@ def bp_forbidden():\n     assert client.get('/nope').data == b'you shall not pass'\n \n \n-def test_blueprint_prefix_slash(app, client):\n-    bp = flask.Blueprint('test', __name__, url_prefix='/bar/')\n-\n-    @bp.route('/foo')\n-    def foo():\n+@pytest.mark.parametrize(('prefix', 'rule', 'url'), (\n+    ('/foo/', '/bar', '/foo/bar'),\n+    ('/foo/', 'bar', '/foo/bar'),\n+    ('/foo', '/bar', '/foo/bar'),\n+    ('/foo/', '//bar', '/foo/bar'),\n+    ('/foo//', '/bar', '/foo/bar'),\n+))\n+def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n+    bp = flask.Blueprint('test', __name__, url_prefix=prefix)\n+\n+    @bp.route(rule)\n+    def index():\n         return '', 204\n \n     app.register_blueprint(bp)\n-    app.register_blueprint(bp, url_prefix='/spam/')\n-    assert client.get('/bar/foo').status_code == 204\n-    assert client.get('/spam/foo').status_code == 204\n+    assert client.get(url).status_code == 204\n \n \n def test_blueprint_url_defaults(app, client):\n\n                ### Fix the Code:", "completion": "@pytest.mark.parametrize(('prefix', 'rule', 'url'), (\n    ('/foo/', '/bar', '/foo/bar'),\n    ('/foo/', 'bar', '/foo/bar'),\n    ('/foo', '/bar', '/foo/bar'),\n    ('/foo/', '//bar', '/foo/bar'),\n    ('/foo//', '/bar', '/foo/bar'),\n))\ndef test_blueprint_prefix_slash(app, client, prefix, rule, url):\n    bp = flask.Blueprint('test', __name__, url_prefix=prefix)\n\n    @bp.route(rule)\n    def index():\n    assert client.get(url).status_code == 204"}
{"prompt": "### Repository:\n                pallets/flask\n\n                ### Issue:\n                Fix registering partials as view functions\n\n                ### Buggy Code Patch:\n                @@ -201,7 +201,7 @@ def add_url_rule(self, rule, endpoint=None, view_func=None, **options):\n         \"\"\"\n         if endpoint:\n             assert '.' not in endpoint, \"Blueprint endpoints should not contain dots\"\n-        if view_func:\n+        if view_func and hasattr(view_func, '__name__'):\n             assert '.' not in view_func.__name__, \"Blueprint view function name should not contain dots\"\n         self.record(lambda s:\n             s.add_url_rule(rule, endpoint, view_func, **options))\n\n                ### Fix the Code:", "completion": "if view_func and hasattr(view_func, '__name__'):"}
{"prompt": "### Repository:\n                pallets/flask\n\n                ### Issue:\n                safe_join on Windows uses posixpath\n\n                ### Buggy Code Patch:\n                @@ -638,18 +638,24 @@ def wiki_page(filename):\n     :raises: :class:`~werkzeug.exceptions.NotFound` if one or more passed\n             paths fall out of its boundaries.\n     \"\"\"\n+\n+    parts = [directory]\n+\n     for filename in pathnames:\n         if filename != '':\n             filename = posixpath.normpath(filename)\n-        for sep in _os_alt_seps:\n-            if sep in filename:\n-                raise NotFound()\n-        if os.path.isabs(filename) or \\\n-           filename == '..' or \\\n-           filename.startswith('../'):\n+\n+        if (\n+            any(sep in filename for sep in _os_alt_seps)\n+            or os.path.isabs(filename)\n+            or filename == '..'\n+            or filename.startswith('../')\n+        ):\n             raise NotFound()\n-        directory = os.path.join(directory, filename)\n-    return directory\n+\n+        parts.append(filename)\n+\n+    return posixpath.join(*parts)\n \n \n def send_from_directory(directory, filename, **options):\n\n                ### Fix the Code:", "completion": "parts = [directory]\n\n\n        if (\n            any(sep in filename for sep in _os_alt_seps)\n            or os.path.isabs(filename)\n            or filename == '..'\n            or filename.startswith('../')\n        ):\n\n        parts.append(filename)\n\n    return posixpath.join(*parts)"}
{"prompt": "### Repository:\n                pallets/flask\n\n                ### Issue:\n                safe_join on Windows uses posixpath\n\n                ### Buggy Code Patch:\n                @@ -903,21 +903,20 @@ def generate():\n \n \n class TestSafeJoin(object):\n-\n     def test_safe_join(self):\n         # Valid combinations of *args and expected joined paths.\n         passing = (\n-            (('a/b/c', ), 'a/b/c'),\n-            (('/', 'a/', 'b/', 'c/', ), '/a/b/c'),\n-            (('a', 'b', 'c', ), 'a/b/c'),\n-            (('/a', 'b/c', ), '/a/b/c'),\n-            (('a/b', 'X/../c'), 'a/b/c', ),\n-            (('/a/b', 'c/X/..'), '/a/b/c', ),\n+            (('a/b/c',), 'a/b/c'),\n+            (('/', 'a/', 'b/', 'c/'), '/a/b/c'),\n+            (('a', 'b', 'c'), 'a/b/c'),\n+            (('/a', 'b/c'), '/a/b/c'),\n+            (('a/b', 'X/../c'), 'a/b/c'),\n+            (('/a/b', 'c/X/..'), '/a/b/c'),\n             # If last path is '' add a slash\n-            (('/a/b/c', '', ), '/a/b/c/', ),\n+            (('/a/b/c', ''), '/a/b/c/'),\n             # Preserve dot slash\n-            (('/a/b/c', './', ), '/a/b/c/.', ),\n-            (('a/b/c', 'X/..'), 'a/b/c/.', ),\n+            (('/a/b/c', './'), '/a/b/c/.'),\n+            (('a/b/c', 'X/..'), 'a/b/c/.'),\n             # Base directory is always considered safe\n             (('../', 'a/b/c'), '../a/b/c'),\n             (('/..', ), '/..'),\n@@ -931,12 +930,12 @@ def test_safe_join_exceptions(self):\n         failing = (\n             # path.isabs and ``..'' checks\n             ('/a', 'b', '/c'),\n-            ('/a', '../b/c', ),\n+            ('/a', '../b/c'),\n             ('/a', '..', 'b/c'),\n             # Boundaries violations after path normalization\n-            ('/a', 'b/../b/../../c', ),\n+            ('/a', 'b/../b/../../c'),\n             ('/a', 'b', 'c/../..'),\n-            ('/a', 'b/../../c', ),\n+            ('/a', 'b/../../c'),\n         )\n \n         for args in failing:\n\n                ### Fix the Code:", "completion": "(('a/b/c',), 'a/b/c'),\n            (('/', 'a/', 'b/', 'c/'), '/a/b/c'),\n            (('a', 'b', 'c'), 'a/b/c'),\n            (('/a', 'b/c'), '/a/b/c'),\n            (('a/b', 'X/../c'), 'a/b/c'),\n            (('/a/b', 'c/X/..'), '/a/b/c'),\n            (('/a/b/c', ''), '/a/b/c/'),\n            (('/a/b/c', './'), '/a/b/c/.'),\n            (('a/b/c', 'X/..'), 'a/b/c/.'),\n            ('/a', '../b/c'),\n            ('/a', 'b/../b/../../c'),\n            ('/a', 'b/../../c'),"}
{"prompt": "### Repository:\n                pallets/flask\n\n                ### Issue:\n                Ensure error while opening session pops context\n\n                ### Buggy Code Patch:\n                @@ -2002,10 +2002,10 @@ def wsgi_app(self, environ, start_response):\n                                exception context to start the response\n         \"\"\"\n         ctx = self.request_context(environ)\n-        ctx.push()\n         error = None\n         try:\n             try:\n+                ctx.push()\n                 response = self.full_dispatch_request()\n             except Exception as e:\n                 error = e\n\n                ### Fix the Code:", "completion": "ctx.push()"}
{"prompt": "### Repository:\n                pallets/flask\n\n                ### Issue:\n                get mtime in utc\n\n                ### Buggy Code Patch:\n                @@ -517,7 +517,7 @@ def index():\n         assert rv.status_code == 416\n         rv.close()\n \n-        last_modified = datetime.datetime.fromtimestamp(os.path.getmtime(\n+        last_modified = datetime.datetime.utcfromtimestamp(os.path.getmtime(\n             os.path.join(app.root_path, 'static/index.html'))).replace(\n             microsecond=0)\n \n\n                ### Fix the Code:", "completion": "last_modified = datetime.datetime.utcfromtimestamp(os.path.getmtime("}
{"prompt": "### Repository:\n                scikit-learn/scikit-learn\n\n                ### Issue:\n                FIX test_csr_polynomial_expansion_index_overflow on [scipy-dev]\n\n                ### Buggy Code Patch:\n                @@ -1050,8 +1050,10 @@ def test_csr_polynomial_expansion_index_overflow(\n     `scipy.sparse.hstack`.\n     \"\"\"\n     data = [1.0]\n-    row = [0]\n-    col = [n_features - 1]\n+    # Use int32 indices as much as we can\n+    indices_dtype = np.int32 if n_features - 1 <= np.iinfo(np.int32).max else np.int64\n+    row = np.array([0], dtype=indices_dtype)\n+    col = np.array([n_features - 1], dtype=indices_dtype)\n \n     # First degree index\n     expected_indices = [\n\n                ### Fix the Code:", "completion": "# Use int32 indices as much as we can\n    indices_dtype = np.int32 if n_features - 1 <= np.iinfo(np.int32).max else np.int64\n    row = np.array([0], dtype=indices_dtype)\n    col = np.array([n_features - 1], dtype=indices_dtype)"}
{"prompt": "### Repository:\n                scikit-learn/scikit-learn\n\n                ### Issue:\n                API drop Tags.regressor_tags.multi_label\n\n                ### Buggy Code Patch:\n                @@ -98,6 +98,8 @@ class TargetTags:\n         Whether a regressor supports multi-target outputs or a classifier supports\n         multi-class multi-output.\n \n+        See :term:`multi-output` in the glossary.\n+\n     single_output : bool, default=True\n         Whether the target can be single-output. This can be ``False`` if the\n         estimator supports only multi-output cases.\n@@ -150,8 +152,13 @@ class ClassifierTags:\n         classification. Therefore this flag indicates whether the\n         classifier is a binary-classifier-only or not.\n \n+        See :term:`multi-class` in the glossary.\n+\n     multi_label : bool, default=False\n-        Whether the classifier supports multi-label output.\n+        Whether the classifier supports multi-label output: a data point can\n+        be predicted to belong to a variable number of classes.\n+\n+        See :term:`multi-label` in the glossary.\n     \"\"\"\n \n     poor_score: bool = False\n@@ -172,13 +179,9 @@ class RegressorTags:\n         n_informative=1, bias=5.0, noise=20, random_state=42)``. The\n         dataset and values are based on current estimators in scikit-learn\n         and might be replaced by something more systematic.\n-\n-    multi_label : bool, default=False\n-        Whether the regressor supports multilabel output.\n     \"\"\"\n \n     poor_score: bool = False\n-    multi_label: bool = False\n \n \n @dataclass(**_dataclass_args())\n@@ -496,7 +499,6 @@ def _to_new_tags(old_tags, estimator=None):\n     if estimator_type == \"regressor\":\n         regressor_tags = RegressorTags(\n             poor_score=old_tags[\"poor_score\"],\n-            multi_label=old_tags[\"multilabel\"],\n         )\n     else:\n         regressor_tags = None\n@@ -520,18 +522,16 @@ def _to_old_tags(new_tags):\n     \"\"\"Utility function convert old tags (dictionary) to new tags (dataclass).\"\"\"\n     if new_tags.classifier_tags:\n         binary_only = not new_tags.classifier_tags.multi_class\n-        multilabel_clf = new_tags.classifier_tags.multi_label\n+        multilabel = new_tags.classifier_tags.multi_label\n         poor_score_clf = new_tags.classifier_tags.poor_score\n     else:\n         binary_only = False\n-        multilabel_clf = False\n+        multilabel = False\n         poor_score_clf = False\n \n     if new_tags.regressor_tags:\n-        multilabel_reg = new_tags.regressor_tags.multi_label\n         poor_score_reg = new_tags.regressor_tags.poor_score\n     else:\n-        multilabel_reg = False\n         poor_score_reg = False\n \n     if new_tags.transformer_tags:\n@@ -543,7 +543,7 @@ def _to_old_tags(new_tags):\n         \"allow_nan\": new_tags.input_tags.allow_nan,\n         \"array_api_support\": new_tags.array_api_support,\n         \"binary_only\": binary_only,\n-        \"multilabel\": multilabel_clf or multilabel_reg,\n+        \"multilabel\": multilabel,\n         \"multioutput\": new_tags.target_tags.multi_output,\n         \"multioutput_only\": (\n             not new_tags.target_tags.single_output and new_tags.target_tags.multi_output\n\n                ### Fix the Code:", "completion": "See :term:`multi-output` in the glossary.\n\n        See :term:`multi-class` in the glossary.\n\n        Whether the classifier supports multi-label output: a data point can\n        be predicted to belong to a variable number of classes.\n\n        See :term:`multi-label` in the glossary.\n        multilabel = new_tags.classifier_tags.multi_label\n        multilabel = False\n        \"multilabel\": multilabel,"}
{"prompt": "### Repository:\n                scikit-learn/scikit-learn\n\n                ### Issue:\n                API drop Tags.regressor_tags.multi_label\n\n                ### Buggy Code Patch:\n                @@ -434,7 +434,6 @@ def __sklearn_tags__(self):\n             classifier_tags = None\n             regressor_tags = RegressorTags(\n                 poor_score=True,\n-                multi_label=True,\n             )\n             return Tags(\n                 estimator_type=self._estimator_type,\n@@ -452,7 +451,7 @@ def __sklearn_tags__(self):\n         \"allow_nan\": True,\n         \"array_api_support\": False,\n         \"binary_only\": False,\n-        \"multilabel\": True,\n+        \"multilabel\": False,\n         \"multioutput\": True,\n         \"multioutput_only\": True,\n         \"no_validation\": False,\n\n                ### Fix the Code:", "completion": "\"multilabel\": False,"}
{"prompt": "### Repository:\n                TheAlgorithms/Python\n\n                ### Issue:\n                Fixes LGTM issues\n\n                ### Buggy Code Patch:\n                @@ -4,17 +4,18 @@\n \n class SearchProblem:\n     \"\"\"\n-    A interface to define search problems. The interface will be illustrated using\n-        the example of mathematical function.\n+    An interface to define search problems.\n+    The interface will be illustrated using the example of mathematical function.\n     \"\"\"\n \n     def __init__(self, x: int, y: int, step_size: int, function_to_optimize):\n         \"\"\"\n         The constructor of the search problem.\n-            x: the x coordinate of the current search state.\n-            y: the y coordinate of the current search state.\n-            step_size: size of the step to take when looking for neighbors.\n-            function_to_optimize: a function to optimize having the signature f(x, y).\n+\n+        x: the x coordinate of the current search state.\n+        y: the y coordinate of the current search state.\n+        step_size: size of the step to take when looking for neighbors.\n+        function_to_optimize: a function to optimize having the signature f(x, y).\n         \"\"\"\n         self.x = x\n         self.y = y\n@@ -63,6 +64,14 @@ def __hash__(self):\n         \"\"\"\n         return hash(str(self))\n \n+    def __eq__(self, obj):\n+        \"\"\"\n+        Check if the 2 objects are equal.\n+        \"\"\"\n+        if isinstance(obj, SearchProblem):\n+            return hash(str(self)) == hash(str(obj))\n+        return False\n+\n     def __str__(self):\n         \"\"\"\n         string representation of the current search state.\n@@ -85,10 +94,11 @@ def hill_climbing(\n     max_iter: int = 10000,\n ) -> SearchProblem:\n     \"\"\"\n-    implementation of the hill climbling algorithm. We start with a given state, find\n-        all its neighbors, move towards the neighbor which provides the maximum (or\n-        minimum) change. We keep doing this until we are at a state where we do not\n-        have any neighbors which can improve the solution.\n+    Implementation of the hill climbling algorithm.\n+    We start with a given state, find all its neighbors,\n+    move towards the neighbor which provides the maximum (or minimum) change.\n+    We keep doing this until we are at a state where we do not have any\n+    neighbors which can improve the solution.\n         Args:\n             search_prob: The search state at the start.\n             find_max: If True, the algorithm should find the maximum else the minimum.\n\n                ### Fix the Code:", "completion": "An interface to define search problems.\n    The interface will be illustrated using the example of mathematical function.\n\n        x: the x coordinate of the current search state.\n        y: the y coordinate of the current search state.\n        step_size: size of the step to take when looking for neighbors.\n        function_to_optimize: a function to optimize having the signature f(x, y).\n    def __eq__(self, obj):\n        \"\"\"\n        Check if the 2 objects are equal.\n        \"\"\"\n        if isinstance(obj, SearchProblem):\n            return hash(str(self)) == hash(str(obj))\n        return False\n\n    Implementation of the hill climbling algorithm.\n    We start with a given state, find all its neighbors,\n    move towards the neighbor which provides the maximum (or minimum) change.\n    We keep doing this until we are at a state where we do not have any\n    neighbors which can improve the solution."}
